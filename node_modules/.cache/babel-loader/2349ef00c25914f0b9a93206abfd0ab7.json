{"ast":null,"code":"import { hierarchy } from 'd3-hierarchy';\nimport { version } from '../package.json';\nconst defaults = Object.freeze({\n  children: data => data.children,\n  nodeSize: node => node.data.size,\n  spacing: 0\n}); // Create a layout function with customizable options. Per D3-style, the\n// options can be set at any time using setter methods. The layout function\n// will compute the tree node positions based on the options in effect at the\n// time it is called.\n\nexport default function flextree(options) {\n  const opts = Object.assign({}, defaults, options);\n\n  function accessor(name) {\n    const opt = opts[name];\n    return typeof opt === 'function' ? opt : () => opt;\n  }\n\n  function layout(tree) {\n    const wtree = wrap(getWrapper(), tree, node => node.children);\n    wtree.update();\n    return wtree.data;\n  }\n\n  function getFlexNode() {\n    const nodeSize = accessor('nodeSize');\n    const spacing = accessor('spacing');\n    return class FlexNode extends hierarchy.prototype.constructor {\n      constructor(data) {\n        super(data);\n      }\n\n      copy() {\n        const c = wrap(this.constructor, this, node => node.children);\n        c.each(node => node.data = node.data.data);\n        return c;\n      }\n\n      get size() {\n        return nodeSize(this);\n      }\n\n      spacing(oNode) {\n        return spacing(this, oNode);\n      }\n\n      get nodes() {\n        return this.descendants();\n      }\n\n      get xSize() {\n        return this.size[0];\n      }\n\n      get ySize() {\n        return this.size[1];\n      }\n\n      get top() {\n        return this.y;\n      }\n\n      get bottom() {\n        return this.y + this.ySize;\n      }\n\n      get left() {\n        return this.x - this.xSize / 2;\n      }\n\n      get right() {\n        return this.x + this.xSize / 2;\n      }\n\n      get root() {\n        const ancs = this.ancestors();\n        return ancs[ancs.length - 1];\n      }\n\n      get numChildren() {\n        return this.hasChildren ? this.children.length : 0;\n      }\n\n      get hasChildren() {\n        return !this.noChildren;\n      }\n\n      get noChildren() {\n        return this.children === null;\n      }\n\n      get firstChild() {\n        return this.hasChildren ? this.children[0] : null;\n      }\n\n      get lastChild() {\n        return this.hasChildren ? this.children[this.numChildren - 1] : null;\n      }\n\n      get extents() {\n        return (this.children || []).reduce((acc, kid) => FlexNode.maxExtents(acc, kid.extents), this.nodeExtents);\n      }\n\n      get nodeExtents() {\n        return {\n          top: this.top,\n          bottom: this.bottom,\n          left: this.left,\n          right: this.right\n        };\n      }\n\n      static maxExtents(e0, e1) {\n        return {\n          top: Math.min(e0.top, e1.top),\n          bottom: Math.max(e0.bottom, e1.bottom),\n          left: Math.min(e0.left, e1.left),\n          right: Math.max(e0.right, e1.right)\n        };\n      }\n\n    };\n  }\n\n  function getWrapper() {\n    const FlexNode = getFlexNode();\n    const nodeSize = accessor('nodeSize');\n    const spacing = accessor('spacing');\n    return class extends FlexNode {\n      constructor(data) {\n        super(data);\n        Object.assign(this, {\n          x: 0,\n          y: 0,\n          relX: 0,\n          prelim: 0,\n          shift: 0,\n          change: 0,\n          lExt: this,\n          lExtRelX: 0,\n          lThr: null,\n          rExt: this,\n          rExtRelX: 0,\n          rThr: null\n        });\n      }\n\n      get size() {\n        return nodeSize(this.data);\n      }\n\n      spacing(oNode) {\n        return spacing(this.data, oNode.data);\n      }\n\n      get x() {\n        return this.data.x;\n      }\n\n      set x(v) {\n        this.data.x = v;\n      }\n\n      get y() {\n        return this.data.y;\n      }\n\n      set y(v) {\n        this.data.y = v;\n      }\n\n      update() {\n        layoutChildren(this);\n        resolveX(this);\n        return this;\n      }\n\n    };\n  }\n\n  function wrap(FlexClass, treeData, children) {\n    const _wrap = (data, parent) => {\n      const node = new FlexClass(data);\n      Object.assign(node, {\n        parent,\n        depth: parent === null ? 0 : parent.depth + 1,\n        height: 0,\n        length: 1\n      });\n      const kidsData = children(data) || [];\n      node.children = kidsData.length === 0 ? null : kidsData.map(kd => _wrap(kd, node));\n\n      if (node.children) {\n        Object.assign(node, node.children.reduce((hl, kid) => ({\n          height: Math.max(hl.height, kid.height + 1),\n          length: hl.length + kid.length\n        }), node));\n      }\n\n      return node;\n    };\n\n    return _wrap(treeData, null);\n  }\n\n  Object.assign(layout, {\n    nodeSize(arg) {\n      return arguments.length ? (opts.nodeSize = arg, layout) : opts.nodeSize;\n    },\n\n    spacing(arg) {\n      return arguments.length ? (opts.spacing = arg, layout) : opts.spacing;\n    },\n\n    children(arg) {\n      return arguments.length ? (opts.children = arg, layout) : opts.children;\n    },\n\n    hierarchy(treeData, children) {\n      const kids = typeof children === 'undefined' ? opts.children : children;\n      return wrap(getFlexNode(), treeData, kids);\n    },\n\n    dump(tree) {\n      const nodeSize = accessor('nodeSize');\n\n      const _dump = i0 => node => {\n        const i1 = i0 + '  ';\n        const i2 = i0 + '    ';\n        const {\n          x,\n          y\n        } = node;\n        const size = nodeSize(node);\n        const kids = node.children || [];\n        const kdumps = kids.length === 0 ? ' ' : `,${i1}children: [${i2}${kids.map(_dump(i2)).join(i2)}${i1}],${i0}`;\n        return `{ size: [${size.join(', ')}],${i1}x: ${x}, y: ${y}${kdumps}},`;\n      };\n\n      return _dump('\\n')(tree);\n    }\n\n  });\n  return layout;\n}\nflextree.version = version;\n\nconst layoutChildren = function (w) {\n  let y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  w.y = y;\n  (w.children || []).reduce((acc, kid) => {\n    const [i, lastLows] = acc;\n    layoutChildren(kid, w.y + w.ySize); // The lowest vertical coordinate while extreme nodes still point\n    // in current subtree.\n\n    const lowY = (i === 0 ? kid.lExt : kid.rExt).bottom;\n    if (i !== 0) separate(w, i, lastLows);\n    const lows = updateLows(lowY, i, lastLows);\n    return [i + 1, lows];\n  }, [0, null]);\n  shiftChange(w);\n  positionRoot(w);\n  return w;\n}; // Resolves the relative coordinate properties - relX and prelim --\n// to set the final, absolute x coordinate for each node. This also sets\n// `prelim` to 0, so that `relX` for each node is its x-coordinate relative\n// to its parent.\n\n\nconst resolveX = (w, prevSum, parentX) => {\n  // A call to resolveX without arguments is assumed to be for the root of\n  // the tree. This will set the root's x-coord to zero.\n  if (typeof prevSum === 'undefined') {\n    prevSum = -w.relX - w.prelim;\n    parentX = 0;\n  }\n\n  const sum = prevSum + w.relX;\n  w.relX = sum + w.prelim - parentX;\n  w.prelim = 0;\n  w.x = parentX + w.relX;\n  (w.children || []).forEach(k => resolveX(k, sum, w.x));\n  return w;\n}; // Process shift and change for all children, to add intermediate spacing to\n// each child's modifier.\n\n\nconst shiftChange = w => {\n  (w.children || []).reduce((acc, child) => {\n    const [lastShiftSum, lastChangeSum] = acc;\n    const shiftSum = lastShiftSum + child.shift;\n    const changeSum = lastChangeSum + shiftSum + child.change;\n    child.relX += changeSum;\n    return [shiftSum, changeSum];\n  }, [0, 0]);\n}; // Separates the latest child from its previous sibling\n\n/* eslint-disable complexity */\n\n\nconst separate = (w, i, lows) => {\n  const lSib = w.children[i - 1];\n  const curSubtree = w.children[i];\n  let rContour = lSib;\n  let rSumMods = lSib.relX;\n  let lContour = curSubtree;\n  let lSumMods = curSubtree.relX;\n  let isFirst = true;\n\n  while (rContour && lContour) {\n    if (rContour.bottom > lows.lowY) lows = lows.next; // How far to the left of the right side of rContour is the left side\n    // of lContour? First compute the center-to-center distance, then add\n    // the \"spacing\"\n\n    const dist = rSumMods + rContour.prelim - (lSumMods + lContour.prelim) + rContour.xSize / 2 + lContour.xSize / 2 + rContour.spacing(lContour);\n\n    if (dist > 0 || dist < 0 && isFirst) {\n      lSumMods += dist; // Move subtree by changing relX.\n\n      moveSubtree(curSubtree, dist);\n      distributeExtra(w, i, lows.index, dist);\n    }\n\n    isFirst = false; // Advance highest node(s) and sum(s) of modifiers\n\n    const rightBottom = rContour.bottom;\n    const leftBottom = lContour.bottom;\n\n    if (rightBottom <= leftBottom) {\n      rContour = nextRContour(rContour);\n      if (rContour) rSumMods += rContour.relX;\n    }\n\n    if (rightBottom >= leftBottom) {\n      lContour = nextLContour(lContour);\n      if (lContour) lSumMods += lContour.relX;\n    }\n  } // Set threads and update extreme nodes. In the first case, the\n  // current subtree is taller than the left siblings.\n\n\n  if (!rContour && lContour) setLThr(w, i, lContour, lSumMods); // In the next case, the left siblings are taller than the current subtree\n  else if (rContour && !lContour) setRThr(w, i, rContour, rSumMods);\n};\n/* eslint-enable complexity */\n// Move subtree by changing relX.\n\n\nconst moveSubtree = (subtree, distance) => {\n  subtree.relX += distance;\n  subtree.lExtRelX += distance;\n  subtree.rExtRelX += distance;\n};\n\nconst distributeExtra = (w, curSubtreeI, leftSibI, dist) => {\n  const curSubtree = w.children[curSubtreeI];\n  const n = curSubtreeI - leftSibI; // Are there intermediate children?\n\n  if (n > 1) {\n    const delta = dist / n;\n    w.children[leftSibI + 1].shift += delta;\n    curSubtree.shift -= delta;\n    curSubtree.change -= dist - delta;\n  }\n};\n\nconst nextLContour = w => {\n  return w.hasChildren ? w.firstChild : w.lThr;\n};\n\nconst nextRContour = w => {\n  return w.hasChildren ? w.lastChild : w.rThr;\n};\n\nconst setLThr = (w, i, lContour, lSumMods) => {\n  const firstChild = w.firstChild;\n  const lExt = firstChild.lExt;\n  const curSubtree = w.children[i];\n  lExt.lThr = lContour; // Change relX so that the sum of modifier after following thread is correct.\n\n  const diff = lSumMods - lContour.relX - firstChild.lExtRelX;\n  lExt.relX += diff; // Change preliminary x coordinate so that the node does not move.\n\n  lExt.prelim -= diff; // Update extreme node and its sum of modifiers.\n\n  firstChild.lExt = curSubtree.lExt;\n  firstChild.lExtRelX = curSubtree.lExtRelX;\n}; // Mirror image of setLThr.\n\n\nconst setRThr = (w, i, rContour, rSumMods) => {\n  const curSubtree = w.children[i];\n  const rExt = curSubtree.rExt;\n  const lSib = w.children[i - 1];\n  rExt.rThr = rContour;\n  const diff = rSumMods - rContour.relX - curSubtree.rExtRelX;\n  rExt.relX += diff;\n  rExt.prelim -= diff;\n  curSubtree.rExt = lSib.rExt;\n  curSubtree.rExtRelX = lSib.rExtRelX;\n}; // Position root between children, taking into account their modifiers\n\n\nconst positionRoot = w => {\n  if (w.hasChildren) {\n    const k0 = w.firstChild;\n    const kf = w.lastChild;\n    const prelim = (k0.prelim + k0.relX - k0.xSize / 2 + kf.relX + kf.prelim + kf.xSize / 2) / 2;\n    Object.assign(w, {\n      prelim,\n      lExt: k0.lExt,\n      lExtRelX: k0.lExtRelX,\n      rExt: kf.rExt,\n      rExtRelX: kf.rExtRelX\n    });\n  }\n}; // Make/maintain a linked list of the indexes of left siblings and their\n// lowest vertical coordinate.\n\n\nconst updateLows = (lowY, index, lastLows) => {\n  // Remove siblings that are hidden by the new subtree.\n  while (lastLows !== null && lowY >= lastLows.lowY) lastLows = lastLows.next; // Prepend the new subtree.\n\n\n  return {\n    lowY,\n    index,\n    next: lastLows\n  };\n};","map":{"version":3,"names":["hierarchy","version","defaults","Object","freeze","children","data","nodeSize","node","size","spacing","flextree","options","opts","assign","accessor","name","opt","layout","tree","wtree","wrap","getWrapper","update","getFlexNode","FlexNode","prototype","constructor","copy","c","each","oNode","nodes","descendants","xSize","ySize","top","y","bottom","left","x","right","root","ancs","ancestors","length","numChildren","hasChildren","noChildren","firstChild","lastChild","extents","reduce","acc","kid","maxExtents","nodeExtents","e0","e1","Math","min","max","relX","prelim","shift","change","lExt","lExtRelX","lThr","rExt","rExtRelX","rThr","v","layoutChildren","resolveX","FlexClass","treeData","_wrap","parent","depth","height","kidsData","map","kd","hl","arg","arguments","kids","dump","_dump","i0","i1","i2","kdumps","join","w","i","lastLows","lowY","separate","lows","updateLows","shiftChange","positionRoot","prevSum","parentX","sum","forEach","k","child","lastShiftSum","lastChangeSum","shiftSum","changeSum","lSib","curSubtree","rContour","rSumMods","lContour","lSumMods","isFirst","next","dist","moveSubtree","distributeExtra","index","rightBottom","leftBottom","nextRContour","nextLContour","setLThr","setRThr","subtree","distance","curSubtreeI","leftSibI","n","delta","diff","k0","kf"],"sources":["/Users/marcomazzucato/Desktop/org-chart/node_modules/d3-flextree/src/flextree.js"],"sourcesContent":["import {hierarchy} from 'd3-hierarchy';\nimport {version} from '../package.json';\n\nconst defaults = Object.freeze({\n  children: data => data.children,\n  nodeSize: node => node.data.size,\n  spacing: 0,\n});\n\n// Create a layout function with customizable options. Per D3-style, the\n// options can be set at any time using setter methods. The layout function\n// will compute the tree node positions based on the options in effect at the\n// time it is called.\nexport default function flextree(options) {\n  const opts = Object.assign({}, defaults, options);\n  function accessor(name) {\n    const opt = opts[name];\n    return typeof opt === 'function' ? opt : () => opt;\n  }\n\n  function layout(tree) {\n    const wtree = wrap(getWrapper(), tree, node=>node.children);\n    wtree.update();\n    return wtree.data;\n  }\n\n  function getFlexNode() {\n    const nodeSize = accessor('nodeSize');\n    const spacing = accessor('spacing');\n    return class FlexNode extends hierarchy.prototype.constructor {\n      constructor(data) {\n        super(data);\n      }\n      copy() {\n        const c = wrap(this.constructor, this, node=>node.children);\n        c.each(node => node.data = node.data.data);\n        return c;\n      }\n      get size() { return nodeSize(this); }\n      spacing(oNode) { return spacing(this, oNode); }\n      get nodes() { return this.descendants(); }\n      get xSize() { return this.size[0]; }\n      get ySize() { return this.size[1]; }\n      get top() { return this.y; }\n      get bottom() { return this.y + this.ySize; }\n      get left() { return this.x - this.xSize / 2; }\n      get right() { return this.x + this.xSize / 2; }\n      get root() {\n        const ancs = this.ancestors();\n        return ancs[ancs.length - 1];\n      }\n      get numChildren() {\n        return this.hasChildren ? this.children.length : 0;\n      }\n      get hasChildren() { return !this.noChildren; }\n      get noChildren() { return this.children === null; }\n      get firstChild() {\n        return this.hasChildren ? this.children[0] : null;\n      }\n      get lastChild() {\n        return this.hasChildren ? this.children[this.numChildren - 1] : null;\n      }\n      get extents() {\n        return (this.children || []).reduce(\n          (acc, kid) => FlexNode.maxExtents(acc, kid.extents),\n          this.nodeExtents);\n      }\n      get nodeExtents() {\n        return {\n          top: this.top,\n          bottom: this.bottom,\n          left: this.left,\n          right: this.right,\n        };\n      }\n      static maxExtents(e0, e1) {\n        return {\n          top: Math.min(e0.top, e1.top),\n          bottom: Math.max(e0.bottom, e1.bottom),\n          left: Math.min(e0.left, e1.left),\n          right: Math.max(e0.right, e1.right),\n        };\n      }\n    };\n  }\n\n  function getWrapper() {\n    const FlexNode = getFlexNode();\n    const nodeSize = accessor('nodeSize');\n    const spacing = accessor('spacing');\n    return class extends FlexNode {\n      constructor(data) {\n        super(data);\n        Object.assign(this, {\n          x: 0, y: 0,\n          relX: 0, prelim: 0, shift: 0, change: 0,\n          lExt: this, lExtRelX: 0, lThr: null,\n          rExt: this, rExtRelX: 0, rThr: null,\n        });\n      }\n      get size() { return nodeSize(this.data); }\n      spacing(oNode) { return spacing(this.data, oNode.data); }\n      get x() { return this.data.x; }\n      set x(v) { this.data.x = v; }\n      get y() { return this.data.y; }\n      set y(v) { this.data.y = v; }\n      update() {\n        layoutChildren(this);\n        resolveX(this);\n        return this;\n      }\n    };\n  }\n\n  function wrap(FlexClass, treeData, children) {\n    const _wrap = (data, parent) => {\n      const node = new FlexClass(data);\n      Object.assign(node, {\n        parent,\n        depth: parent === null ? 0 : parent.depth + 1,\n        height: 0,\n        length: 1,\n      });\n      const kidsData = children(data) || [];\n      node.children = kidsData.length === 0 ? null\n        : kidsData.map(kd => _wrap(kd, node));\n      if (node.children) {\n        Object.assign(node, node.children.reduce(\n          (hl, kid) => ({\n            height: Math.max(hl.height, kid.height + 1),\n            length: hl.length + kid.length,\n          }), node\n        ));\n      }\n      return node;\n    };\n    return _wrap(treeData, null);\n  }\n\n\n  Object.assign(layout, {\n    nodeSize(arg) {\n      return arguments.length ? (opts.nodeSize = arg, layout) : opts.nodeSize;\n    },\n    spacing(arg) {\n      return arguments.length ? (opts.spacing = arg, layout) : opts.spacing;\n    },\n    children(arg) {\n      return arguments.length ? (opts.children = arg, layout) : opts.children;\n    },\n    hierarchy(treeData, children) {\n      const kids = typeof children === 'undefined' ? opts.children : children;\n      return wrap(getFlexNode(), treeData, kids);\n    },\n    dump(tree) {\n      const nodeSize = accessor('nodeSize');\n      const _dump = i0 => node => {\n        const i1 = i0 + '  ';\n        const i2 = i0 + '    ';\n        const {x, y} = node;\n        const size = nodeSize(node);\n        const kids = (node.children || []);\n        const kdumps = (kids.length === 0) ? ' ' :\n          `,${i1}children: [${i2}${kids.map(_dump(i2)).join(i2)}${i1}],${i0}`;\n        return `{ size: [${size.join(', ')}],${i1}x: ${x}, y: ${y}${kdumps}},`;\n      };\n      return _dump('\\n')(tree);\n    },\n  });\n  return layout;\n}\nflextree.version = version;\n\nconst layoutChildren = (w, y = 0) => {\n  w.y = y;\n  (w.children || []).reduce((acc, kid) => {\n    const [i, lastLows] = acc;\n    layoutChildren(kid, w.y + w.ySize);\n    // The lowest vertical coordinate while extreme nodes still point\n    // in current subtree.\n    const lowY = (i === 0 ? kid.lExt : kid.rExt).bottom;\n    if (i !== 0) separate(w, i, lastLows);\n    const lows = updateLows(lowY, i, lastLows);\n    return [i + 1, lows];\n  }, [0, null]);\n  shiftChange(w);\n  positionRoot(w);\n  return w;\n};\n\n// Resolves the relative coordinate properties - relX and prelim --\n// to set the final, absolute x coordinate for each node. This also sets\n// `prelim` to 0, so that `relX` for each node is its x-coordinate relative\n// to its parent.\nconst resolveX = (w, prevSum, parentX) => {\n  // A call to resolveX without arguments is assumed to be for the root of\n  // the tree. This will set the root's x-coord to zero.\n  if (typeof prevSum === 'undefined') {\n    prevSum = -w.relX - w.prelim;\n    parentX = 0;\n  }\n  const sum = prevSum + w.relX;\n  w.relX = sum + w.prelim - parentX;\n  w.prelim = 0;\n  w.x = parentX + w.relX;\n  (w.children || []).forEach(k => resolveX(k, sum, w.x));\n  return w;\n};\n\n// Process shift and change for all children, to add intermediate spacing to\n// each child's modifier.\nconst shiftChange = w => {\n  (w.children || []).reduce((acc, child) => {\n    const [lastShiftSum, lastChangeSum] = acc;\n    const shiftSum = lastShiftSum + child.shift;\n    const changeSum = lastChangeSum + shiftSum + child.change;\n    child.relX += changeSum;\n    return [shiftSum, changeSum];\n  }, [0, 0]);\n};\n\n// Separates the latest child from its previous sibling\n/* eslint-disable complexity */\nconst separate = (w, i, lows) => {\n  const lSib = w.children[i - 1];\n  const curSubtree = w.children[i];\n  let rContour = lSib;\n  let rSumMods = lSib.relX;\n  let lContour = curSubtree;\n  let lSumMods = curSubtree.relX;\n  let isFirst = true;\n  while (rContour && lContour) {\n    if (rContour.bottom > lows.lowY) lows = lows.next;\n    // How far to the left of the right side of rContour is the left side\n    // of lContour? First compute the center-to-center distance, then add\n    // the \"spacing\"\n    const dist =\n      (rSumMods + rContour.prelim) - (lSumMods + lContour.prelim) +\n      rContour.xSize / 2 + lContour.xSize / 2 +\n      rContour.spacing(lContour);\n    if (dist > 0 || (dist < 0 && isFirst)) {\n      lSumMods += dist;\n      // Move subtree by changing relX.\n      moveSubtree(curSubtree, dist);\n      distributeExtra(w, i, lows.index, dist);\n    }\n    isFirst = false;\n    // Advance highest node(s) and sum(s) of modifiers\n    const rightBottom = rContour.bottom;\n    const leftBottom = lContour.bottom;\n    if (rightBottom <= leftBottom) {\n      rContour = nextRContour(rContour);\n      if (rContour) rSumMods += rContour.relX;\n    }\n    if (rightBottom >= leftBottom) {\n      lContour = nextLContour(lContour);\n      if (lContour) lSumMods += lContour.relX;\n    }\n  }\n  // Set threads and update extreme nodes. In the first case, the\n  // current subtree is taller than the left siblings.\n  if (!rContour && lContour) setLThr(w, i, lContour, lSumMods);\n  // In the next case, the left siblings are taller than the current subtree\n  else if (rContour && !lContour) setRThr(w, i, rContour, rSumMods);\n};\n/* eslint-enable complexity */\n\n// Move subtree by changing relX.\nconst moveSubtree = (subtree, distance) => {\n  subtree.relX += distance;\n  subtree.lExtRelX += distance;\n  subtree.rExtRelX += distance;\n};\n\nconst distributeExtra = (w, curSubtreeI, leftSibI, dist) => {\n  const curSubtree = w.children[curSubtreeI];\n  const n = curSubtreeI - leftSibI;\n  // Are there intermediate children?\n  if (n > 1) {\n    const delta = dist / n;\n    w.children[leftSibI + 1].shift += delta;\n    curSubtree.shift -= delta;\n    curSubtree.change -= dist - delta;\n  }\n};\n\nconst nextLContour = w => {\n  return w.hasChildren ? w.firstChild : w.lThr;\n};\n\nconst nextRContour = w => {\n  return w.hasChildren ? w.lastChild : w.rThr;\n};\n\nconst setLThr = (w, i, lContour, lSumMods) => {\n  const firstChild = w.firstChild;\n  const lExt = firstChild.lExt;\n  const curSubtree = w.children[i];\n  lExt.lThr = lContour;\n  // Change relX so that the sum of modifier after following thread is correct.\n  const diff = lSumMods - lContour.relX - firstChild.lExtRelX;\n  lExt.relX += diff;\n  // Change preliminary x coordinate so that the node does not move.\n  lExt.prelim -= diff;\n  // Update extreme node and its sum of modifiers.\n  firstChild.lExt = curSubtree.lExt;\n  firstChild.lExtRelX = curSubtree.lExtRelX;\n};\n\n// Mirror image of setLThr.\nconst setRThr = (w, i, rContour, rSumMods) => {\n  const curSubtree = w.children[i];\n  const rExt = curSubtree.rExt;\n  const lSib = w.children[i - 1];\n  rExt.rThr = rContour;\n  const diff = rSumMods - rContour.relX - curSubtree.rExtRelX;\n  rExt.relX += diff;\n  rExt.prelim -= diff;\n  curSubtree.rExt = lSib.rExt;\n  curSubtree.rExtRelX = lSib.rExtRelX;\n};\n\n// Position root between children, taking into account their modifiers\nconst positionRoot = w => {\n  if (w.hasChildren) {\n    const k0 = w.firstChild;\n    const kf = w.lastChild;\n    const prelim = (k0.prelim + k0.relX - k0.xSize / 2 +\n      kf.relX + kf.prelim + kf.xSize / 2 ) / 2;\n    Object.assign(w, {\n      prelim,\n      lExt: k0.lExt, lExtRelX: k0.lExtRelX,\n      rExt: kf.rExt, rExtRelX: kf.rExtRelX,\n    });\n  }\n};\n\n// Make/maintain a linked list of the indexes of left siblings and their\n// lowest vertical coordinate.\nconst updateLows = (lowY, index, lastLows) => {\n  // Remove siblings that are hidden by the new subtree.\n  while (lastLows !== null && lowY >= lastLows.lowY)\n    lastLows = lastLows.next;\n  // Prepend the new subtree.\n  return {\n    lowY,\n    index,\n    next: lastLows,\n  };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}