{"ast":null,"code":"import _slicedToArray from \"/Users/marcomazzucato/Desktop/org-chart/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _assertThisInitialized from \"/Users/marcomazzucato/Desktop/org-chart/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _classCallCheck from \"/Users/marcomazzucato/Desktop/org-chart/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/marcomazzucato/Desktop/org-chart/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/marcomazzucato/Desktop/org-chart/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/marcomazzucato/Desktop/org-chart/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { hierarchy } from 'd3-hierarchy';\nimport packageInfo from '../package.json';\nvar version = packageInfo.version;\nvar defaults = Object.freeze({\n  children: function children(data) {\n    return data.children;\n  },\n  nodeSize: function nodeSize(node) {\n    return node.data.size;\n  },\n  spacing: 0\n}); // Create a layout function with customizable options. Per D3-style, the\n// options can be set at any time using setter methods. The layout function\n// will compute the tree node positions based on the options in effect at the\n// time it is called.\n\nexport default function flextree(options) {\n  var opts = Object.assign({}, defaults, options);\n\n  function accessor(name) {\n    var opt = opts[name];\n    return typeof opt === 'function' ? opt : function () {\n      return opt;\n    };\n  }\n\n  function layout(tree) {\n    var wtree = wrap(getWrapper(), tree, function (node) {\n      return node.children;\n    });\n    wtree.update();\n    return wtree.data;\n  }\n\n  function getFlexNode() {\n    var nodeSize = accessor('nodeSize');\n\n    var _spacing = accessor('spacing');\n\n    return /*#__PURE__*/function (_hierarchy$prototype$) {\n      _inherits(FlexNode, _hierarchy$prototype$);\n\n      var _super = _createSuper(FlexNode);\n\n      function FlexNode(data) {\n        _classCallCheck(this, FlexNode);\n\n        return _super.call(this, data);\n      }\n\n      _createClass(FlexNode, [{\n        key: \"copy\",\n        value: function copy() {\n          var c = wrap(this.constructor, this, function (node) {\n            return node.children;\n          });\n          c.each(function (node) {\n            return node.data = node.data.data;\n          });\n          return c;\n        }\n      }, {\n        key: \"size\",\n        get: function get() {\n          return nodeSize(this);\n        }\n      }, {\n        key: \"spacing\",\n        value: function spacing(oNode) {\n          return _spacing(this, oNode);\n        }\n      }, {\n        key: \"nodes\",\n        get: function get() {\n          return this.descendants();\n        }\n      }, {\n        key: \"xSize\",\n        get: function get() {\n          return this.size[0];\n        }\n      }, {\n        key: \"ySize\",\n        get: function get() {\n          return this.size[1];\n        }\n      }, {\n        key: \"top\",\n        get: function get() {\n          return this.y;\n        }\n      }, {\n        key: \"bottom\",\n        get: function get() {\n          return this.y + this.ySize;\n        }\n      }, {\n        key: \"left\",\n        get: function get() {\n          return this.x - this.xSize / 2;\n        }\n      }, {\n        key: \"right\",\n        get: function get() {\n          return this.x + this.xSize / 2;\n        }\n      }, {\n        key: \"root\",\n        get: function get() {\n          var ancs = this.ancestors();\n          return ancs[ancs.length - 1];\n        }\n      }, {\n        key: \"numChildren\",\n        get: function get() {\n          return this.hasChildren ? this.children.length : 0;\n        }\n      }, {\n        key: \"hasChildren\",\n        get: function get() {\n          return !this.noChildren;\n        }\n      }, {\n        key: \"noChildren\",\n        get: function get() {\n          return this.children === null;\n        }\n      }, {\n        key: \"firstChild\",\n        get: function get() {\n          return this.hasChildren ? this.children[0] : null;\n        }\n      }, {\n        key: \"lastChild\",\n        get: function get() {\n          return this.hasChildren ? this.children[this.numChildren - 1] : null;\n        }\n      }, {\n        key: \"extents\",\n        get: function get() {\n          return (this.children || []).reduce(function (acc, kid) {\n            return FlexNode.maxExtents(acc, kid.extents);\n          }, this.nodeExtents);\n        }\n      }, {\n        key: \"nodeExtents\",\n        get: function get() {\n          return {\n            top: this.top,\n            bottom: this.bottom,\n            left: this.left,\n            right: this.right\n          };\n        }\n      }], [{\n        key: \"maxExtents\",\n        value: function maxExtents(e0, e1) {\n          return {\n            top: Math.min(e0.top, e1.top),\n            bottom: Math.max(e0.bottom, e1.bottom),\n            left: Math.min(e0.left, e1.left),\n            right: Math.max(e0.right, e1.right)\n          };\n        }\n      }]);\n\n      return FlexNode;\n    }(hierarchy.prototype.constructor);\n  }\n\n  function getWrapper() {\n    var FlexNode = getFlexNode();\n    var nodeSize = accessor('nodeSize');\n\n    var _spacing2 = accessor('spacing');\n\n    return /*#__PURE__*/function (_FlexNode) {\n      _inherits(_class, _FlexNode);\n\n      var _super2 = _createSuper(_class);\n\n      function _class(data) {\n        var _this;\n\n        _classCallCheck(this, _class);\n\n        _this = _super2.call(this, data);\n        Object.assign(_assertThisInitialized(_this), {\n          x: 0,\n          y: 0,\n          relX: 0,\n          prelim: 0,\n          shift: 0,\n          change: 0,\n          lExt: _assertThisInitialized(_this),\n          lExtRelX: 0,\n          lThr: null,\n          rExt: _assertThisInitialized(_this),\n          rExtRelX: 0,\n          rThr: null\n        });\n        return _this;\n      }\n\n      _createClass(_class, [{\n        key: \"size\",\n        get: function get() {\n          return nodeSize(this.data);\n        }\n      }, {\n        key: \"spacing\",\n        value: function spacing(oNode) {\n          return _spacing2(this.data, oNode.data);\n        }\n      }, {\n        key: \"x\",\n        get: function get() {\n          return this.data.x;\n        },\n        set: function set(v) {\n          this.data.x = v;\n        }\n      }, {\n        key: \"y\",\n        get: function get() {\n          return this.data.y;\n        },\n        set: function set(v) {\n          this.data.y = v;\n        }\n      }, {\n        key: \"update\",\n        value: function update() {\n          layoutChildren(this);\n          resolveX(this);\n          return this;\n        }\n      }]);\n\n      return _class;\n    }(FlexNode);\n  }\n\n  function wrap(FlexClass, treeData, children) {\n    var _wrap = function _wrap(data, parent) {\n      var node = new FlexClass(data);\n      Object.assign(node, {\n        parent: parent,\n        depth: parent === null ? 0 : parent.depth + 1,\n        height: 0,\n        length: 1\n      });\n      var kidsData = children(data) || [];\n      node.children = kidsData.length === 0 ? null : kidsData.map(function (kd) {\n        return _wrap(kd, node);\n      });\n\n      if (node.children) {\n        Object.assign(node, node.children.reduce(function (hl, kid) {\n          return {\n            height: Math.max(hl.height, kid.height + 1),\n            length: hl.length + kid.length\n          };\n        }, node));\n      }\n\n      return node;\n    };\n\n    return _wrap(treeData, null);\n  }\n\n  Object.assign(layout, {\n    nodeSize: function nodeSize(arg) {\n      return arguments.length ? (opts.nodeSize = arg, layout) : opts.nodeSize;\n    },\n    spacing: function spacing(arg) {\n      return arguments.length ? (opts.spacing = arg, layout) : opts.spacing;\n    },\n    children: function children(arg) {\n      return arguments.length ? (opts.children = arg, layout) : opts.children;\n    },\n    hierarchy: function hierarchy(treeData, children) {\n      var kids = typeof children === 'undefined' ? opts.children : children;\n      return wrap(getFlexNode(), treeData, kids);\n    },\n    dump: function dump(tree) {\n      var nodeSize = accessor('nodeSize');\n\n      var _dump = function _dump(i0) {\n        return function (node) {\n          var i1 = i0 + '  ';\n          var i2 = i0 + '    ';\n          var x = node.x,\n              y = node.y;\n          var size = nodeSize(node);\n          var kids = node.children || [];\n          var kdumps = kids.length === 0 ? ' ' : \",\".concat(i1, \"children: [\").concat(i2).concat(kids.map(_dump(i2)).join(i2)).concat(i1, \"],\").concat(i0);\n          return \"{ size: [\".concat(size.join(', '), \"],\").concat(i1, \"x: \").concat(x, \", y: \").concat(y).concat(kdumps, \"},\");\n        };\n      };\n\n      return _dump('\\n')(tree);\n    }\n  });\n  return layout;\n}\nflextree.version = version;\n\nvar layoutChildren = function layoutChildren(w) {\n  var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  w.y = y;\n  (w.children || []).reduce(function (acc, kid) {\n    var _acc = _slicedToArray(acc, 2),\n        i = _acc[0],\n        lastLows = _acc[1];\n\n    layoutChildren(kid, w.y + w.ySize); // The lowest vertical coordinate while extreme nodes still point\n    // in current subtree.\n\n    var lowY = (i === 0 ? kid.lExt : kid.rExt).bottom;\n    if (i !== 0) separate(w, i, lastLows);\n    var lows = updateLows(lowY, i, lastLows);\n    return [i + 1, lows];\n  }, [0, null]);\n  shiftChange(w);\n  positionRoot(w);\n  return w;\n}; // Resolves the relative coordinate properties - relX and prelim --\n// to set the final, absolute x coordinate for each node. This also sets\n// `prelim` to 0, so that `relX` for each node is its x-coordinate relative\n// to its parent.\n\n\nvar resolveX = function resolveX(w, prevSum, parentX) {\n  // A call to resolveX without arguments is assumed to be for the root of\n  // the tree. This will set the root's x-coord to zero.\n  if (typeof prevSum === 'undefined') {\n    prevSum = -w.relX - w.prelim;\n    parentX = 0;\n  }\n\n  var sum = prevSum + w.relX;\n  w.relX = sum + w.prelim - parentX;\n  w.prelim = 0;\n  w.x = parentX + w.relX;\n  (w.children || []).forEach(function (k) {\n    return resolveX(k, sum, w.x);\n  });\n  return w;\n}; // Process shift and change for all children, to add intermediate spacing to\n// each child's modifier.\n\n\nvar shiftChange = function shiftChange(w) {\n  (w.children || []).reduce(function (acc, child) {\n    var _acc2 = _slicedToArray(acc, 2),\n        lastShiftSum = _acc2[0],\n        lastChangeSum = _acc2[1];\n\n    var shiftSum = lastShiftSum + child.shift;\n    var changeSum = lastChangeSum + shiftSum + child.change;\n    child.relX += changeSum;\n    return [shiftSum, changeSum];\n  }, [0, 0]);\n}; // Separates the latest child from its previous sibling\n\n/* eslint-disable complexity */\n\n\nvar separate = function separate(w, i, lows) {\n  var lSib = w.children[i - 1];\n  var curSubtree = w.children[i];\n  var rContour = lSib;\n  var rSumMods = lSib.relX;\n  var lContour = curSubtree;\n  var lSumMods = curSubtree.relX;\n  var isFirst = true;\n\n  while (rContour && lContour) {\n    if (rContour.bottom > lows.lowY) lows = lows.next; // How far to the left of the right side of rContour is the left side\n    // of lContour? First compute the center-to-center distance, then add\n    // the \"spacing\"\n\n    var dist = rSumMods + rContour.prelim - (lSumMods + lContour.prelim) + rContour.xSize / 2 + lContour.xSize / 2 + rContour.spacing(lContour);\n\n    if (dist > 0 || dist < 0 && isFirst) {\n      lSumMods += dist; // Move subtree by changing relX.\n\n      moveSubtree(curSubtree, dist);\n      distributeExtra(w, i, lows.index, dist);\n    }\n\n    isFirst = false; // Advance highest node(s) and sum(s) of modifiers\n\n    var rightBottom = rContour.bottom;\n    var leftBottom = lContour.bottom;\n\n    if (rightBottom <= leftBottom) {\n      rContour = nextRContour(rContour);\n      if (rContour) rSumMods += rContour.relX;\n    }\n\n    if (rightBottom >= leftBottom) {\n      lContour = nextLContour(lContour);\n      if (lContour) lSumMods += lContour.relX;\n    }\n  } // Set threads and update extreme nodes. In the first case, the\n  // current subtree is taller than the left siblings.\n\n\n  if (!rContour && lContour) setLThr(w, i, lContour, lSumMods); // In the next case, the left siblings are taller than the current subtree\n  else if (rContour && !lContour) setRThr(w, i, rContour, rSumMods);\n};\n/* eslint-enable complexity */\n// Move subtree by changing relX.\n\n\nvar moveSubtree = function moveSubtree(subtree, distance) {\n  subtree.relX += distance;\n  subtree.lExtRelX += distance;\n  subtree.rExtRelX += distance;\n};\n\nvar distributeExtra = function distributeExtra(w, curSubtreeI, leftSibI, dist) {\n  var curSubtree = w.children[curSubtreeI];\n  var n = curSubtreeI - leftSibI; // Are there intermediate children?\n\n  if (n > 1) {\n    var delta = dist / n;\n    w.children[leftSibI + 1].shift += delta;\n    curSubtree.shift -= delta;\n    curSubtree.change -= dist - delta;\n  }\n};\n\nvar nextLContour = function nextLContour(w) {\n  return w.hasChildren ? w.firstChild : w.lThr;\n};\n\nvar nextRContour = function nextRContour(w) {\n  return w.hasChildren ? w.lastChild : w.rThr;\n};\n\nvar setLThr = function setLThr(w, i, lContour, lSumMods) {\n  var firstChild = w.firstChild;\n  var lExt = firstChild.lExt;\n  var curSubtree = w.children[i];\n  lExt.lThr = lContour; // Change relX so that the sum of modifier after following thread is correct.\n\n  var diff = lSumMods - lContour.relX - firstChild.lExtRelX;\n  lExt.relX += diff; // Change preliminary x coordinate so that the node does not move.\n\n  lExt.prelim -= diff; // Update extreme node and its sum of modifiers.\n\n  firstChild.lExt = curSubtree.lExt;\n  firstChild.lExtRelX = curSubtree.lExtRelX;\n}; // Mirror image of setLThr.\n\n\nvar setRThr = function setRThr(w, i, rContour, rSumMods) {\n  var curSubtree = w.children[i];\n  var rExt = curSubtree.rExt;\n  var lSib = w.children[i - 1];\n  rExt.rThr = rContour;\n  var diff = rSumMods - rContour.relX - curSubtree.rExtRelX;\n  rExt.relX += diff;\n  rExt.prelim -= diff;\n  curSubtree.rExt = lSib.rExt;\n  curSubtree.rExtRelX = lSib.rExtRelX;\n}; // Position root between children, taking into account their modifiers\n\n\nvar positionRoot = function positionRoot(w) {\n  if (w.hasChildren) {\n    var k0 = w.firstChild;\n    var kf = w.lastChild;\n    var prelim = (k0.prelim + k0.relX - k0.xSize / 2 + kf.relX + kf.prelim + kf.xSize / 2) / 2;\n    Object.assign(w, {\n      prelim: prelim,\n      lExt: k0.lExt,\n      lExtRelX: k0.lExtRelX,\n      rExt: kf.rExt,\n      rExtRelX: kf.rExtRelX\n    });\n  }\n}; // Make/maintain a linked list of the indexes of left siblings and their\n// lowest vertical coordinate.\n\n\nvar updateLows = function updateLows(lowY, index, lastLows) {\n  // Remove siblings that are hidden by the new subtree.\n  while (lastLows !== null && lowY >= lastLows.lowY) {\n    lastLows = lastLows.next;\n  } // Prepend the new subtree.\n\n\n  return {\n    lowY: lowY,\n    index: index,\n    next: lastLows\n  };\n};","map":{"version":3,"names":["hierarchy","packageInfo","version","defaults","Object","freeze","children","data","nodeSize","node","size","spacing","flextree","options","opts","assign","accessor","name","opt","layout","tree","wtree","wrap","getWrapper","update","getFlexNode","c","constructor","each","oNode","descendants","y","ySize","x","xSize","ancs","ancestors","length","hasChildren","noChildren","numChildren","reduce","acc","kid","FlexNode","maxExtents","extents","nodeExtents","top","bottom","left","right","e0","e1","Math","min","max","prototype","relX","prelim","shift","change","lExt","lExtRelX","lThr","rExt","rExtRelX","rThr","v","layoutChildren","resolveX","FlexClass","treeData","_wrap","parent","depth","height","kidsData","map","kd","hl","arg","arguments","kids","dump","_dump","i0","i1","i2","kdumps","join","w","i","lastLows","lowY","separate","lows","updateLows","shiftChange","positionRoot","prevSum","parentX","sum","forEach","k","child","lastShiftSum","lastChangeSum","shiftSum","changeSum","lSib","curSubtree","rContour","rSumMods","lContour","lSumMods","isFirst","next","dist","moveSubtree","distributeExtra","index","rightBottom","leftBottom","nextRContour","nextLContour","setLThr","setRThr","subtree","distance","curSubtreeI","leftSibI","n","delta","firstChild","lastChild","diff","k0","kf"],"sources":["/Users/marcomazzucato/Desktop/org-chart/node_modules/d3-flextree/src/flextree.js"],"sourcesContent":["import {hierarchy} from 'd3-hierarchy';\nimport packageInfo from '../package.json';\n\nconst {version} = packageInfo;\nconst defaults = Object.freeze({\n  children: data => data.children,\n  nodeSize: node => node.data.size,\n  spacing: 0,\n});\n\n// Create a layout function with customizable options. Per D3-style, the\n// options can be set at any time using setter methods. The layout function\n// will compute the tree node positions based on the options in effect at the\n// time it is called.\nexport default function flextree(options) {\n  const opts = Object.assign({}, defaults, options);\n  function accessor(name) {\n    const opt = opts[name];\n    return typeof opt === 'function' ? opt : () => opt;\n  }\n\n  function layout(tree) {\n    const wtree = wrap(getWrapper(), tree, node=>node.children);\n    wtree.update();\n    return wtree.data;\n  }\n\n  function getFlexNode() {\n    const nodeSize = accessor('nodeSize');\n    const spacing = accessor('spacing');\n    return class FlexNode extends hierarchy.prototype.constructor {\n      constructor(data) {\n        super(data);\n      }\n      copy() {\n        const c = wrap(this.constructor, this, node=>node.children);\n        c.each(node => node.data = node.data.data);\n        return c;\n      }\n      get size() { return nodeSize(this); }\n      spacing(oNode) { return spacing(this, oNode); }\n      get nodes() { return this.descendants(); }\n      get xSize() { return this.size[0]; }\n      get ySize() { return this.size[1]; }\n      get top() { return this.y; }\n      get bottom() { return this.y + this.ySize; }\n      get left() { return this.x - this.xSize / 2; }\n      get right() { return this.x + this.xSize / 2; }\n      get root() {\n        const ancs = this.ancestors();\n        return ancs[ancs.length - 1];\n      }\n      get numChildren() {\n        return this.hasChildren ? this.children.length : 0;\n      }\n      get hasChildren() { return !this.noChildren; }\n      get noChildren() { return this.children === null; }\n      get firstChild() {\n        return this.hasChildren ? this.children[0] : null;\n      }\n      get lastChild() {\n        return this.hasChildren ? this.children[this.numChildren - 1] : null;\n      }\n      get extents() {\n        return (this.children || []).reduce(\n          (acc, kid) => FlexNode.maxExtents(acc, kid.extents),\n          this.nodeExtents);\n      }\n      get nodeExtents() {\n        return {\n          top: this.top,\n          bottom: this.bottom,\n          left: this.left,\n          right: this.right,\n        };\n      }\n      static maxExtents(e0, e1) {\n        return {\n          top: Math.min(e0.top, e1.top),\n          bottom: Math.max(e0.bottom, e1.bottom),\n          left: Math.min(e0.left, e1.left),\n          right: Math.max(e0.right, e1.right),\n        };\n      }\n    };\n  }\n\n  function getWrapper() {\n    const FlexNode = getFlexNode();\n    const nodeSize = accessor('nodeSize');\n    const spacing = accessor('spacing');\n    return class extends FlexNode {\n      constructor(data) {\n        super(data);\n        Object.assign(this, {\n          x: 0, y: 0,\n          relX: 0, prelim: 0, shift: 0, change: 0,\n          lExt: this, lExtRelX: 0, lThr: null,\n          rExt: this, rExtRelX: 0, rThr: null,\n        });\n      }\n      get size() { return nodeSize(this.data); }\n      spacing(oNode) { return spacing(this.data, oNode.data); }\n      get x() { return this.data.x; }\n      set x(v) { this.data.x = v; }\n      get y() { return this.data.y; }\n      set y(v) { this.data.y = v; }\n      update() {\n        layoutChildren(this);\n        resolveX(this);\n        return this;\n      }\n    };\n  }\n\n  function wrap(FlexClass, treeData, children) {\n    const _wrap = (data, parent) => {\n      const node = new FlexClass(data);\n      Object.assign(node, {\n        parent,\n        depth: parent === null ? 0 : parent.depth + 1,\n        height: 0,\n        length: 1,\n      });\n      const kidsData = children(data) || [];\n      node.children = kidsData.length === 0 ? null\n        : kidsData.map(kd => _wrap(kd, node));\n      if (node.children) {\n        Object.assign(node, node.children.reduce(\n          (hl, kid) => ({\n            height: Math.max(hl.height, kid.height + 1),\n            length: hl.length + kid.length,\n          }), node\n        ));\n      }\n      return node;\n    };\n    return _wrap(treeData, null);\n  }\n\n\n  Object.assign(layout, {\n    nodeSize(arg) {\n      return arguments.length ? (opts.nodeSize = arg, layout) : opts.nodeSize;\n    },\n    spacing(arg) {\n      return arguments.length ? (opts.spacing = arg, layout) : opts.spacing;\n    },\n    children(arg) {\n      return arguments.length ? (opts.children = arg, layout) : opts.children;\n    },\n    hierarchy(treeData, children) {\n      const kids = typeof children === 'undefined' ? opts.children : children;\n      return wrap(getFlexNode(), treeData, kids);\n    },\n    dump(tree) {\n      const nodeSize = accessor('nodeSize');\n      const _dump = i0 => node => {\n        const i1 = i0 + '  ';\n        const i2 = i0 + '    ';\n        const {x, y} = node;\n        const size = nodeSize(node);\n        const kids = (node.children || []);\n        const kdumps = (kids.length === 0) ? ' ' :\n          `,${i1}children: [${i2}${kids.map(_dump(i2)).join(i2)}${i1}],${i0}`;\n        return `{ size: [${size.join(', ')}],${i1}x: ${x}, y: ${y}${kdumps}},`;\n      };\n      return _dump('\\n')(tree);\n    },\n  });\n  return layout;\n}\nflextree.version = version;\n\nconst layoutChildren = (w, y = 0) => {\n  w.y = y;\n  (w.children || []).reduce((acc, kid) => {\n    const [i, lastLows] = acc;\n    layoutChildren(kid, w.y + w.ySize);\n    // The lowest vertical coordinate while extreme nodes still point\n    // in current subtree.\n    const lowY = (i === 0 ? kid.lExt : kid.rExt).bottom;\n    if (i !== 0) separate(w, i, lastLows);\n    const lows = updateLows(lowY, i, lastLows);\n    return [i + 1, lows];\n  }, [0, null]);\n  shiftChange(w);\n  positionRoot(w);\n  return w;\n};\n\n// Resolves the relative coordinate properties - relX and prelim --\n// to set the final, absolute x coordinate for each node. This also sets\n// `prelim` to 0, so that `relX` for each node is its x-coordinate relative\n// to its parent.\nconst resolveX = (w, prevSum, parentX) => {\n  // A call to resolveX without arguments is assumed to be for the root of\n  // the tree. This will set the root's x-coord to zero.\n  if (typeof prevSum === 'undefined') {\n    prevSum = -w.relX - w.prelim;\n    parentX = 0;\n  }\n  const sum = prevSum + w.relX;\n  w.relX = sum + w.prelim - parentX;\n  w.prelim = 0;\n  w.x = parentX + w.relX;\n  (w.children || []).forEach(k => resolveX(k, sum, w.x));\n  return w;\n};\n\n// Process shift and change for all children, to add intermediate spacing to\n// each child's modifier.\nconst shiftChange = w => {\n  (w.children || []).reduce((acc, child) => {\n    const [lastShiftSum, lastChangeSum] = acc;\n    const shiftSum = lastShiftSum + child.shift;\n    const changeSum = lastChangeSum + shiftSum + child.change;\n    child.relX += changeSum;\n    return [shiftSum, changeSum];\n  }, [0, 0]);\n};\n\n// Separates the latest child from its previous sibling\n/* eslint-disable complexity */\nconst separate = (w, i, lows) => {\n  const lSib = w.children[i - 1];\n  const curSubtree = w.children[i];\n  let rContour = lSib;\n  let rSumMods = lSib.relX;\n  let lContour = curSubtree;\n  let lSumMods = curSubtree.relX;\n  let isFirst = true;\n  while (rContour && lContour) {\n    if (rContour.bottom > lows.lowY) lows = lows.next;\n    // How far to the left of the right side of rContour is the left side\n    // of lContour? First compute the center-to-center distance, then add\n    // the \"spacing\"\n    const dist =\n      (rSumMods + rContour.prelim) - (lSumMods + lContour.prelim) +\n      rContour.xSize / 2 + lContour.xSize / 2 +\n      rContour.spacing(lContour);\n    if (dist > 0 || (dist < 0 && isFirst)) {\n      lSumMods += dist;\n      // Move subtree by changing relX.\n      moveSubtree(curSubtree, dist);\n      distributeExtra(w, i, lows.index, dist);\n    }\n    isFirst = false;\n    // Advance highest node(s) and sum(s) of modifiers\n    const rightBottom = rContour.bottom;\n    const leftBottom = lContour.bottom;\n    if (rightBottom <= leftBottom) {\n      rContour = nextRContour(rContour);\n      if (rContour) rSumMods += rContour.relX;\n    }\n    if (rightBottom >= leftBottom) {\n      lContour = nextLContour(lContour);\n      if (lContour) lSumMods += lContour.relX;\n    }\n  }\n  // Set threads and update extreme nodes. In the first case, the\n  // current subtree is taller than the left siblings.\n  if (!rContour && lContour) setLThr(w, i, lContour, lSumMods);\n  // In the next case, the left siblings are taller than the current subtree\n  else if (rContour && !lContour) setRThr(w, i, rContour, rSumMods);\n};\n/* eslint-enable complexity */\n\n// Move subtree by changing relX.\nconst moveSubtree = (subtree, distance) => {\n  subtree.relX += distance;\n  subtree.lExtRelX += distance;\n  subtree.rExtRelX += distance;\n};\n\nconst distributeExtra = (w, curSubtreeI, leftSibI, dist) => {\n  const curSubtree = w.children[curSubtreeI];\n  const n = curSubtreeI - leftSibI;\n  // Are there intermediate children?\n  if (n > 1) {\n    const delta = dist / n;\n    w.children[leftSibI + 1].shift += delta;\n    curSubtree.shift -= delta;\n    curSubtree.change -= dist - delta;\n  }\n};\n\nconst nextLContour = w => {\n  return w.hasChildren ? w.firstChild : w.lThr;\n};\n\nconst nextRContour = w => {\n  return w.hasChildren ? w.lastChild : w.rThr;\n};\n\nconst setLThr = (w, i, lContour, lSumMods) => {\n  const firstChild = w.firstChild;\n  const lExt = firstChild.lExt;\n  const curSubtree = w.children[i];\n  lExt.lThr = lContour;\n  // Change relX so that the sum of modifier after following thread is correct.\n  const diff = lSumMods - lContour.relX - firstChild.lExtRelX;\n  lExt.relX += diff;\n  // Change preliminary x coordinate so that the node does not move.\n  lExt.prelim -= diff;\n  // Update extreme node and its sum of modifiers.\n  firstChild.lExt = curSubtree.lExt;\n  firstChild.lExtRelX = curSubtree.lExtRelX;\n};\n\n// Mirror image of setLThr.\nconst setRThr = (w, i, rContour, rSumMods) => {\n  const curSubtree = w.children[i];\n  const rExt = curSubtree.rExt;\n  const lSib = w.children[i - 1];\n  rExt.rThr = rContour;\n  const diff = rSumMods - rContour.relX - curSubtree.rExtRelX;\n  rExt.relX += diff;\n  rExt.prelim -= diff;\n  curSubtree.rExt = lSib.rExt;\n  curSubtree.rExtRelX = lSib.rExtRelX;\n};\n\n// Position root between children, taking into account their modifiers\nconst positionRoot = w => {\n  if (w.hasChildren) {\n    const k0 = w.firstChild;\n    const kf = w.lastChild;\n    const prelim = (k0.prelim + k0.relX - k0.xSize / 2 +\n      kf.relX + kf.prelim + kf.xSize / 2 ) / 2;\n    Object.assign(w, {\n      prelim,\n      lExt: k0.lExt, lExtRelX: k0.lExtRelX,\n      rExt: kf.rExt, rExtRelX: kf.rExtRelX,\n    });\n  }\n};\n\n// Make/maintain a linked list of the indexes of left siblings and their\n// lowest vertical coordinate.\nconst updateLows = (lowY, index, lastLows) => {\n  // Remove siblings that are hidden by the new subtree.\n  while (lastLows !== null && lowY >= lastLows.lowY)\n    lastLows = lastLows.next;\n  // Prepend the new subtree.\n  return {\n    lowY,\n    index,\n    next: lastLows,\n  };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}